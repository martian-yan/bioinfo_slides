<!doctype html><html><head><meta charset=UTF-8><title>07_Genome_assembly - By</title><link rel=stylesheet href=http://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=http://cdn.staticfile.org/prism/1.15.0/themes/prism.min.css><link rel=stylesheet href=http://cdn.staticfile.org/KaTeX/0.10.0-rc.1/katex.min.css><link rel=stylesheet href=http://cdn.staticfile.org/KaTeX/0.5.1/katex.min.css><link href=./css/chunk-vendors.1643f5f1.css rel=stylesheet></head><body><div><article id=webslides><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><h1 class="text-landing text-shadow">07_Genome_assembly</h1><hr><p class=text-intro>By Yan Li</p><p class=text-intro>PhD in Bioinformatics, University of Liverpool</p></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Introduction</h2><hr><ul><li>Assembly: from short reads to long contigs</li><li>Two types of genome assembly:<ul><li><strong>de novo</strong></li><li>re-sequencing (reference-guided)</li></ul></li><li>We will focus on <em>de novo</em> of bacterial genome</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Why</h2><hr><ul><li>Make a reference genome (when we are not already have one)</li><li>Look at genome structure</li><li>Put features into context</li><li>To make comparison to other genomes</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Technology choice</h2><hr><ul><li>Different assembler based on the sequencing platform</li><li>PacBio &amp; Nanopore<ul><li>Flye</li></ul></li><li>Illumina<ul><li><strong>Spades</strong></li><li>Velvet</li></ul></li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Factors dictate assemly quality</h2><hr><ul><li>Read length and coverage</li><li>Sequencing data quality</li><li>Genome complexity</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Coverage / Depth</h2><hr><p><img src=./img/coverage.9ec3a54d.png alt=coverage></p><ul><li>Usually expressed as 30x, 100x, etc</li><li>Low coverage cause some genome regions have no reads</li><li>Short reads length may make repeat regions impossible to recover</li></ul></div><div class=speaker-note><div class=wrap><p g(length\space="" of\space="" genome)="">\frac{N(number\space of\space reads) * L (read\space length)}</p><p>https:://katex.org/#demo</p></div></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Terminology</h2><hr><table><thead><tr><th style=text-align:left>Term</th><th style=text-align:left>Definition</th></tr></thead><tbody><tr><td style=text-align:left>assembly</td><td style=text-align:left>reconstructing a genome sequence from raw reads</td></tr><tr><td style=text-align:left>read</td><td style=text-align:left>fragments of genome generated by a sequencer</td></tr><tr><td style=text-align:left>coverage</td><td style=text-align:left>the average number of reads that align to known reference bases</td></tr><tr><td style=text-align:left>contig</td><td style=text-align:left>a contigious sequence built from overlapping reads</td></tr><tr><td style=text-align:left>scaffold</td><td style=text-align:left>sets of overlapping contigs separated by gaps of known length</td></tr><tr><td style=text-align:left>graph</td><td style=text-align:left>represents relationships using nodes and edges</td></tr></tbody></table></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><p><img src=./img/assembly.113edbc8.png alt=assembly></p></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Graph theory: the Seven Bridges of Königsberg</h2><hr><p><img src=./img/Konigsberg_bridges.ce585060.png alt=seven-bridge></p><p>Can we visit each part of the city by crossing each bridge once?</p></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Graph theory: the Seven Bridges of Königsberg</h2><hr><p><img src=./img/graph-theory.a435d866.png alt=graph-theory></p><ul><li>Eulerian path = visit every edge of the graph only once</li><li>In this problem it's impossible</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>de Bruijn graph</h2><hr><ul><li>Reads are broken into k-mers (substrings of length k)</li><li>A de Bruijn graph is is constructed from the k-mers: k-mers are connected if they have k-1 shared bases</li><li>The genome is derived using the Eulerian path through the graph</li><li>E.G. assemblers: SPAdes, Velvet, ABySS</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>de Bruijn graph assembler</h2><hr><p><img src=./img/Illustration-of-de-Bruijn-graph-based-assembly.2fe5f0d8.png alt=assembler></p></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Graph features</h2><hr><p><img src=./img/graph-features.356dbf63.png alt="graph features"></p><p>Use k-mer frequency to resolve these graph features::</p><ul><li>remove low depth kmers</li><li>clip tips, merge bubbles, remove links</li><li>resolve small repeats using long kmers</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>K-mer size</h2><hr><ul><li>avoid using an even numbered k-mer size<ul><li>they can lead to reverse complementing</li><li>affects the strand specificity of the graph</li><li>palindromic k-mers are avoided with an odd k</li></ul></li><li>inceasing k-mer size can resolve ambiguities<ul><li>higher k-mer size can &lt; number of edges and &lt; possible paths</li><li>however higher k-mer size also more sensitive to sequencing errors</li><li>higher k-mer size means more RAM needed</li></ul></li><li>try several k-mer sizes to get the best assembly</li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Assembly quality</h2><hr><p>We assess quality by looking at the assembly <strong>contiguity</strong>, <strong>completeness</strong> and <strong>correctness</strong></p></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Contiguity</h2><hr><ul><li>Ideally, we want a single complete chromosome</li><li>We measure contiguity using::<ul><li>contig number</li><li>contig length (average, median and maximum)</li><li>N statistics (e.g. N50)</li></ul></li><li>N50 is a statistical measure of the average length of a set of contigs<ul><li>50% of the entire assembly is contained in contigs with length &gt;= the N50 value</li></ul></li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Completeness and correctness</h2><hr><ul><li>Completeness = assembled genome size / estimated genomes size</li><li>Correctness is a measure of the number of errors in the assembly<ul><li>feature compressions (i.e. repeats)</li><li>improper contig scaffolding</li><li>introduced SNPs/InDels</li></ul></li></ul></div></section><section slide class="slide bg-light aligncenter"><div class=wrap wrap=true><h2>Workshop</h2><hr><p>We will do:</p><ul><li>Assemble: <a href=https://github.com/ablab/spades target=_blank><code>SPAdes</code> <i class="fa fa-external-link"></i></a></li><li>Quality assessment: <a href=http://bioinf.spbau.ru/quast target=_blank><code>Quast</code> <i class="fa fa-external-link"></i></a></li><li>Visualise: <a href=https://rrwick.github.io/Bandage/ target=_blank><code>bandage</code> <i class="fa fa-external-link"></i></a></li><li>Annotation: <a href=https://github.com/tseemann/prokka target=_blank><code>Prokka</code> <i class="fa fa-external-link"></i></a></li></ul></div></section></article></div><script>window.pluginsOptions = {}



document.addEventListener('DOMContentLoaded', () => {
    let isPrintMode = false;
    if(~location.search.indexOf('print-pdf')){
        isPrintMode = true;
        WebSlides.registerPlugin('scroll', function(){});
    }
    const ws = new WebSlides({
        loop: false
    })
    window.wsInstance = ws;
    if(isPrintMode){
        ws.slides.forEach(s=>s.show())
    }
}, false)</script><script src=./js/chunk-vendors.e98a8274.js></script><script src=./js/07_Genome_assembly.82795eb1.js></script></body></html>